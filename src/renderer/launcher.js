/**
 * EMINIUM LAUNCHER - VERSION COMPL√àTE ET FONCTIONNELLE
 * Launcher Minecraft avec authentification Azuriom et interface moderne
 */

// Configuration
const CONFIG = {
    AZURIOM_URL: 'https://eminium.ovh',
    DEBUG: true,
    TIMEOUT: 15000
};

// =============================================================================
// OUTILS DE BASE
// =============================================================================

const DOM = {
    select: (selector) => document.querySelector(selector),
    selectAll: (selector) => document.querySelectorAll(selector),

    setText: (id, text) => {
        const el = DOM.select(`#${id}`);
        if (el) el.textContent = text;
    },

    setDisplay: (id, display) => {
        const el = DOM.select(`#${id}`);
        if (el) el.style.display = display;
    },

    getValue: (id) => {
        const el = DOM.select(`#${id}`);
        return el ? el.value : '';
    },

    setValue: (id, value) => {
        const el = DOM.select(`#${id}`);
        if (el) el.value = value;
    },

    addClick: (id, handler) => {
        const el = DOM.select(`#${id}`);
        if (el) el.addEventListener('click', handler);
    },

    addSubmit: (id, handler) => {
        const el = DOM.select(`#${id}`);
        if (el) el.addEventListener('submit', handler);
    },

    addInput: (id, handler) => {
        const el = DOM.select(`#${id}`);
        if (el) el.addEventListener('input', handler);
    }
};

// =============================================================================
// LOGGER
// =============================================================================

const Logger = {
    log: (message, data) => {
        if (CONFIG.DEBUG) {
            console.log(`[${new Date().toLocaleTimeString()}] ${message}`, data || '');
        }
    },

    error: (message, error) => {
        console.error(`[${new Date().toLocaleTimeString()}] ERROR: ${message}`, error || '');
    },

    success: (message, data) => {
        if (CONFIG.DEBUG) {
            console.log(`[${new Date().toLocaleTimeString()}] ‚úÖ ${message}`, data || '');
        }
    }
};

// =============================================================================
// CLASSES D'AUTHENTIFICATION
// =============================================================================

class AzuriomAuth {
    async login(email, password, twoFactorCode = null) {
        Logger.log('üîê Tentative d\'authentification Azuriom', { email, hasTwoFactor: !!twoFactorCode });

        try {
            const data = { email, password };
            if (twoFactorCode && twoFactorCode.trim()) {
                data.code = twoFactorCode.trim();
            }

            // Timeout pour √©viter les blocages
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), CONFIG.TIMEOUT);

            const response = await fetch(`${CONFIG.AZURIOM_URL}/api/auth/authenticate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'User-Agent': 'EminiumLauncher/2.0'
                },
                body: JSON.stringify(data),
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            Logger.log('üì° R√©ponse serveur', {
                status: response.status,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers.entries())
            });

            const result = await response.json();
            Logger.log('üì¶ Corps de la r√©ponse', result);

            // V√©rifier diff√©rents formats de r√©ponse 2FA
            if (response.ok && result.id && result.access_token) {
                Logger.success('üéâ Authentification r√©ussie', { userId: result.id, username: result.username });
                return { success: true, user: result };
            }

            // Format 1: R√©ponse 422 avec status "pending" et reason "2fa"
            if (response.status === 422 && result.status === 'pending' && result.reason === '2fa') {
                Logger.log('üîê Code 2FA requis (format 1)');
                return { success: false, requiresTwoFactor: true, error: 'Code 2FA requis', status: 'pending', reason: '2fa' };
            }

            // Format 2: R√©ponse avec message contenant "2fa" ou "code"
            if (result.message && (result.message.toLowerCase().includes('2fa') || result.message.toLowerCase().includes('code'))) {
                Logger.log('üîê Code 2FA requis (format 2)');
                return { success: false, requiresTwoFactor: true, error: 'Code 2FA requis', message: result.message };
            }

            // Format 3: R√©ponse 401 avec demande de 2FA
            if (response.status === 401 && result.require_2fa) {
                Logger.log('üîê Code 2FA requis (format 3)');
                return { success: false, requiresTwoFactor: true, error: 'Code 2FA requis' };
            }

            Logger.error('‚ùå √âchec d\'authentification', result);
            return {
                success: false,
                error: result.message || `Erreur HTTP ${response.status}: ${response.statusText}`,
                code: result.reason || `HTTP_${response.status}`
            };

        } catch (error) {
            if (error.name === 'AbortError') {
                Logger.error('‚è∞ Timeout de la requ√™te');
                return { success: false, error: 'Timeout - Le serveur met trop de temps √† r√©pondre', code: 'TIMEOUT' };
            }

            Logger.error('üåê Erreur r√©seau', error);
            return { success: false, error: 'Erreur de connexion r√©seau', code: 'NETWORK_ERROR' };
        }
    }

    async logout(token) {
        if (!token) return { success: true };

        try {
            await fetch(`${CONFIG.AZURIOM_URL}/api/auth/logout`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ access_token: token })
            });
            return { success: true };
        } catch (error) {
            Logger.error('Erreur d√©connexion', error);
            return { success: true };
        }
    }
}

// =============================================================================
// CLASSES D'INTERFACE
// =============================================================================

class ProgressUI {
    constructor() {
        this.modal = null;
        this.init();
    }

    init() {
        this.modal = DOM.select('#progressModal');
    }

    open(title = 'Pr√©paration') {
        if (!this.modal) this.createModal();

        DOM.setText('progressTitle', title);
        this.modal.style.display = 'flex';

        // Reset progress
        this.set(0);
        DOM.setText('progressLogContainer', '');

        return this.modal;
    }

    set(percentage) {
        const progressBar = DOM.select('#progressBar');
        const progressText = DOM.select('#progressPercent');

        if (progressBar && progressText) {
            progressBar.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            DOM.setText('progressPercent', `${Math.round(percentage)}%`);
        }
    }

    addLine(text) {
        const container = DOM.select('#progressLogContainer');
        if (container) {
            const line = document.createElement('div');
            line.className = 'progress-line';
            line.textContent = text;
            container.appendChild(line);
            container.scrollTop = container.scrollHeight;
        }
    }

    close() {
        if (this.modal) {
            this.modal.style.display = 'none';
        }
    }

    createModal() {
        // Le modal est d√©j√† dans le HTML
        this.modal = DOM.select('#progressModal');
    }
}

class GameManager {
    async prepareGame() {
        const progressUI = new ProgressUI();
        progressUI.open('Pr√©paration du jeu');

        progressUI.set(10);
        progressUI.addLine('üîç V√©rification des fichiers...');

        await new Promise(resolve => setTimeout(resolve, 1000));

        progressUI.set(50);
        progressUI.addLine('üì¶ T√©l√©chargement des ressources...');

        await new Promise(resolve => setTimeout(resolve, 1500));

        progressUI.set(100);
        progressUI.addLine('‚úÖ Jeu pr√™t !');

        setTimeout(() => progressUI.close(), 1500);
    }

    async launchGame() {
        const progressUI = new ProgressUI();
        progressUI.open('Lancement du jeu');

        progressUI.set(20);
        progressUI.addLine('üöÄ Initialisation du launcher...');

        await new Promise(resolve => setTimeout(resolve, 1000));

        progressUI.set(60);
        progressUI.addLine('üéÆ Connexion au serveur...');

        await new Promise(resolve => setTimeout(resolve, 1500));

        progressUI.set(100);
        progressUI.addLine('üéâ Jeu lanc√© avec succ√®s !');

        setTimeout(() => progressUI.close(), 2000);
    }
}

// =============================================================================
// CLASSE DE GESTION DU TH√àME
// =============================================================================

class ThemeManager {
    constructor() {
        this.isDarkMode = true;
        this.themeToggle = null;
        this.init();
    }

    init() {
        this.themeToggle = DOM.select('#themeToggle');
        if (this.themeToggle) {
            this.themeToggle.addEventListener('click', () => this.toggleTheme());

            // D√©tecter la pr√©f√©rence syst√®me
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                this.setLightTheme();
            }
        }

        // √âcouter les changements de pr√©f√©rence syst√®me
        if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                if (!this.isDarkMode) return; // Ne changer que si on est en mode sombre
                if (e.matches) {
                    this.setLightTheme();
                }
            });
        }
    }

    toggleTheme() {
        if (this.isDarkMode) {
            this.setLightTheme();
        } else {
            this.setDarkTheme();
        }
    }

    setLightTheme() {
        this.isDarkMode = false;
        document.body.classList.add('light-theme');
        if (this.themeToggle) {
            this.themeToggle.querySelector('.icon').textContent = '‚òÄÔ∏è';
            this.themeToggle.title = 'Basculer vers le th√®me sombre';
        }
        Logger.log('üé® Th√®me clair activ√©');
    }

    setDarkTheme() {
        this.isDarkMode = true;
        document.body.classList.remove('light-theme');
        if (this.themeToggle) {
            this.themeToggle.querySelector('.icon').textContent = 'üåô';
            this.themeToggle.title = 'Basculer vers le th√®me clair';
        }
        Logger.log('üé® Th√®me sombre activ√©');
    }
}

// =============================================================================
// CLASSE DE GESTION DE SESSION
// =============================================================================

class SessionManager {
    constructor() {
        this.storageKey = 'eminium_session';
        this.tokenKey = 'eminium_token';
        this.currentSession = null;
    }

    // Sauvegarder la session utilisateur
    saveSession(user) {
        try {
            const sessionData = {
                user: {
                    id: user.id,
                    username: user.username,
                    email: user.email,
                    grade: user.grade,
                    avatar: user.avatar
                },
                token: user.access_token,
                timestamp: Date.now(),
                expiresAt: Date.now() + (24 * 60 * 60 * 1000) // 24 heures
            };

            localStorage.setItem(this.storageKey, JSON.stringify(sessionData));
            localStorage.setItem(this.tokenKey, user.access_token);

            Logger.success('üíæ Session sauvegard√©e', { userId: user.id });
            return true;
        } catch (error) {
            Logger.error('‚ùå Erreur sauvegarde session', error);
            return false;
        }
    }

    // Restaurer la session au d√©marrage
    async restoreSession() {
        try {
            const sessionData = localStorage.getItem(this.storageKey);
            const token = localStorage.getItem(this.tokenKey);

            if (!sessionData || !token) {
                Logger.log('‚ÑπÔ∏è Aucune session sauvegard√©e');
                return null;
            }

            const session = JSON.parse(sessionData);

            // V√©rifier l'expiration
            if (Date.now() > session.expiresAt) {
                Logger.log('‚è∞ Session expir√©e, nettoyage');
                this.clearSession();
                return null;
            }

            // V√©rifier la validit√© du token
            const isValid = await this.validateToken(token);
            if (!isValid) {
                Logger.log('‚ùå Token invalide, nettoyage de la session');
                this.clearSession();
                return null;
            }

            Logger.success('‚úÖ Session restaur√©e', { userId: session.user.id });
            return { ...session.user, access_token: token };

        } catch (error) {
            Logger.error('‚ùå Erreur restauration session', error);
            this.clearSession();
            return null;
        }
    }

    // V√©rifier la validit√© d'un token
    async validateToken(token) {
        try {
            const response = await fetch(`${CONFIG.AZURIOM_URL}/api/auth/verify`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({ access_token: token })
            });

            const result = await response.json();
            return response.ok && result.id;
        } catch (error) {
            Logger.error('‚ùå Erreur validation token', error);
            return false;
        }
    }

    // Nettoyer la session
    clearSession() {
        try {
            localStorage.removeItem(this.storageKey);
            localStorage.removeItem(this.tokenKey);
            Logger.log('üßπ Session nettoy√©e');
        } catch (error) {
            Logger.error('‚ùå Erreur nettoyage session', error);
        }
    }

    // Prolonger la session
    extendSession() {
        try {
            const sessionData = localStorage.getItem(this.storageKey);
            if (sessionData) {
                const session = JSON.parse(sessionData);
                session.expiresAt = Date.now() + (24 * 60 * 60 * 1000); // +24h
                localStorage.setItem(this.storageKey, JSON.stringify(session));
                Logger.log('‚è∞ Session prolong√©e');
            }
        } catch (error) {
            Logger.error('‚ùå Erreur prolongation session', error);
        }
    }
}

// =============================================================================
// CLASSE PRINCIPALE AM√âLIOR√âE AVEC PERSISTANCE
// =============================================================================

class EminiumLauncher {
    constructor() {
        this.auth = new AzuriomAuth();
        this.progressUI = new ProgressUI();
        this.gameManager = new GameManager();
        this.themeManager = new ThemeManager();
        this.sessionManager = new SessionManager();
        this.currentUser = null;
        this.isLoading = false;

        this.init();
    }

    async init() {
        Logger.log('üöÄ Initialisation d\'Eminium Launcher');

        // Restaurer la session existante
        await this.restoreExistingSession();

        // V√©rifier que tous les √©l√©ments DOM existent
        this.checkRequiredElements();

        // Configurer les gestionnaires d'√©v√©nements
        this.setupEventListeners();

        // Configurer la navigation par onglets
        this.setupTabNavigation();

        // D√©marrer l'animation de fond
        this.startBackgroundAnimation();

        // D√©marrer le gestionnaire de session automatique
        this.startSessionManager();

        Logger.success('üéØ Launcher initialis√© avec succ√®s');
    }

    startSessionManager() {
        // Prolonger la session toutes les heures si l'utilisateur est connect√©
        setInterval(() => {
            if (this.currentUser && this.sessionManager) {
                this.sessionManager.extendSession();
            }
        }, 60 * 60 * 1000); // Toutes les heures

        Logger.log('‚è∞ Gestionnaire de session automatique d√©marr√©');
    }

    async restoreExistingSession() {
        Logger.log('üîÑ Tentative de restauration de session');

        const savedUser = await this.sessionManager.restoreSession();
        if (savedUser) {
            this.currentUser = savedUser;
            this.handleLoginSuccess(savedUser);
            Logger.success('üîë Session restaur√©e automatiquement');
        } else {
            Logger.log('‚ÑπÔ∏è D√©marrage sans session existante');
        }
    }

    checkRequiredElements() {
        const required = [
            'email', 'password', 'azuriomBtn', 'loginForm', 'code2fa',
            'loginBtn', 'themeToggle', 'navPlay', 'navLogs'
        ];
        const missing = required.filter(id => !DOM.select(`#${id}`));

        if (missing.length > 0) {
            Logger.error('‚ùå √âl√©ments DOM manquants', missing);
            alert('Erreur: √âl√©ments DOM manquants: ' + missing.join(', '));
            return;
        }

        Logger.success('‚úÖ Tous les √©l√©ments DOM trouv√©s');
    }

    setupEventListeners() {
        Logger.log('üîó Configuration des √©v√©nements');

        // Authentification
        DOM.addClick('azuriomBtn', (e) => this.handleLogin(e));
        DOM.addSubmit('loginForm', (e) => this.handleLogin(e));
        DOM.addClick('logoutBtn', () => this.logout());

        // Jeu
        DOM.addClick('prepareBtn', () => this.gameManager.prepareGame());
        DOM.addClick('playBtn', () => this.gameManager.launchGame());

        Logger.success('‚úÖ √âv√©nements configur√©s');
    }

    setupTabNavigation() {
        Logger.log('üìë Configuration de la navigation par onglets');

        DOM.selectAll('.nav-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const tab = item.getAttribute('data-tab');
                if (tab) {
                    this.switchToTab(tab);
                }
            });
        });

        Logger.success('‚úÖ Navigation par onglets configur√©e');
    }

    switchToTab(tabName) {
        Logger.log('üîÑ Basculement vers l\'onglet', tabName);

        // Masquer tous les onglets
        DOM.selectAll('.content-section').forEach(section => {
            section.style.display = 'none';
        });

        // Afficher l'onglet demand√©
        DOM.setDisplay(`${tabName}Section`, 'block');

        // Mettre √† jour la navigation
        DOM.selectAll('.nav-item').forEach(item => {
            item.classList.remove('active');
        });

        DOM.select(`[data-tab="${tabName}"]`)?.classList.add('active');

        // Actions sp√©ciales par onglet
        if (tabName === 'play') {
            this.updateGameSettings();
        }
    }

    updateGameSettings() {
        // Mettre √† jour les param√®tres de jeu avec les valeurs actuelles du syst√®me
        Logger.log('üéÆ Mise √† jour des param√®tres de jeu');

        // Exemple : d√©tecter automatiquement la RAM disponible
        if (navigator.deviceMemory) {
            const ramGB = navigator.deviceMemory;
            const ramMB = ramGB * 1024;
            DOM.setValue('memSlider', Math.min(ramMB, 8192));
            DOM.setText('memValue', `${Math.min(ramMB, 8192)} Mo`);
        }
    }

    startBackgroundAnimation() {
        // D√©marrer des animations de fond suppl√©mentaires si n√©cessaire
        Logger.log('‚ú® Animation de fond d√©marr√©e');

        // Afficher un message d'information sur la persistance
        setTimeout(() => {
            if (this.currentUser) {
                Logger.log('üí° Session active d√©tect√©e - Vous √™tes automatiquement connect√©');
            } else {
                Logger.log('üí° Lancez le launcher et connectez-vous - votre session sera sauvegard√©e');
            }
        }, 2000);
    }

    async handleLogin(event) {
        Logger.log('üîë Gestionnaire de connexion appel√©');
        event.preventDefault();

        if (this.isLoading) {
            Logger.log('‚è≥ Connexion d√©j√† en cours');
            return;
        }

        const email = DOM.getValue('email');
        const password = DOM.getValue('password');
        const twoFactorCode = DOM.getValue('code2fa');

        Logger.log('üìù Donn√©es saisies', {
            email,
            hasPassword: !!password,
            hasTwoFactor: !!twoFactorCode,
            isTwoFactorVisible: DOM.select('#code2faGroup')?.style.display === 'block'
        });

        if (!email || !password) {
            this.showError('Veuillez saisir votre email et mot de passe');
            return;
        }

        this.setLoading(true);
        this.hideMessages();

        try {
            const result = await this.auth.login(email, password, twoFactorCode);
            Logger.log('üìä R√©sultat de l\'authentification', result);

            if (result.success) {
                this.handleLoginSuccess(result.user);
            } else if (result.requiresTwoFactor) {
                Logger.log('üîê Code 2FA requis, affichage du champ');
                this.showTwoFactorPrompt();
            } else {
                Logger.error('‚ùå √âchec d\'authentification', result.error);
                this.showError(result.error || 'Erreur de connexion');
                this.resetTwoFactorState();
            }
        } catch (error) {
            Logger.error('üí• Erreur lors de la connexion', error);
            this.showError('Erreur de connexion r√©seau');
            this.resetTwoFactorState();
        } finally {
            this.setLoading(false);
        }
    }

    handleLoginSuccess(user) {
        Logger.success('üéâ Connexion r√©ussie', user);
        this.currentUser = user;

        // Sauvegarder la session pour la persistance
        this.sessionManager.saveSession(user);

        // Masquer compl√®tement le champ 2FA lors du succ√®s
        this.resetTwoFactorState();

        // Masquer l'authentification
        DOM.setDisplay('authSection', 'none');

        // Afficher les autres onglets
        DOM.setDisplay('navPlay', 'flex');
        DOM.setDisplay('navLogs', 'flex');

        // Mettre √† jour l'interface utilisateur
        DOM.setDisplay('userCard', 'flex');
        DOM.setDisplay('logoutBtn', 'flex');
        DOM.setText('userName', user.username || user.name || 'Utilisateur');
        DOM.setText('userRole', user.grade?.name || 'Membre');

        this.showSuccess(`Connect√© en tant que ${user.username || user.name || 'Utilisateur'}`);

        // Afficher automatiquement l'onglet de jeu apr√®s 1.5 secondes
        setTimeout(() => {
            this.switchToTab('play');
        }, 1500);
    }

    showTwoFactorPrompt() {
        Logger.log('üîê Affichage du champ 2FA');
        DOM.setDisplay('code2faGroup', 'block');
        DOM.setValue('code2fa', '');
        DOM.setText('loginText', 'V√©rifier le code');

        // Focus automatique apr√®s un court d√©lai
        setTimeout(() => {
            const codeInput = DOM.select('code2fa');
            if (codeInput) {
                codeInput.focus();
                Logger.log('üëÅÔ∏è Focus mis sur le champ 2FA');
            }
        }, 100);
    }

    resetTwoFactorState() {
        Logger.log('üîÑ R√©initialisation de l\'√©tat 2FA');
        DOM.setDisplay('code2faGroup', 'none');
        DOM.setValue('code2fa', '');
        DOM.setText('loginText', 'Se connecter');
    }

    async logout() {
        Logger.log('üö™ D√©connexion demand√©e');

        if (this.currentUser?.access_token) {
            await this.auth.logout(this.currentUser.access_token);
        }

        // Nettoyer la session sauvegard√©e
        this.sessionManager.clearSession();

        this.currentUser = null;

        // Masquer les √©l√©ments connect√©s
        DOM.setDisplay('userCard', 'none');
        DOM.setDisplay('logoutBtn', 'none');
        DOM.setDisplay('navPlay', 'none');
        DOM.setDisplay('navLogs', 'none');

        // Afficher l'authentification
        DOM.setDisplay('authSection', 'block');

        // R√©initialiser le formulaire
        this.resetTwoFactorState();
        this.hideMessages();

        Logger.success('‚úÖ D√©connexion compl√®te effectu√©e');
    }

    switchToPlayTab() {
        // Masquer tous les onglets
        DOM.selectAll('.content-section').forEach(section => {
            section.style.display = 'none';
        });

        // Afficher l'onglet de jeu
        DOM.setDisplay('playSection', 'block');

        // Mettre √† jour la navigation
        DOM.selectAll('.nav-item').forEach(item => {
            item.classList.remove('active');
        });

        DOM.select('[data-tab="play"]')?.classList.add('active');

        Logger.log('üéÆ Basculement vers l\'onglet Jeu');
    }

    setLoading(loading) {
        this.isLoading = loading;
        DOM.setText('loginText', loading ? 'Connexion...' : 'Se connecter');

        const spinner = DOM.select('#loginSpinner');
        if (spinner) {
            spinner.style.display = loading ? 'inline-block' : 'none';
        }

        const loginBtn = DOM.select('#loginBtn');
        if (loginBtn) {
            loginBtn.disabled = loading;
        }
    }

    showError(message) {
        Logger.error('‚ùå Affichage d\'erreur', message);
        DOM.setText('authError', message);
        DOM.setDisplay('authError', 'block');
        DOM.setDisplay('authSuccess', 'none');
    }

    showSuccess(message) {
        Logger.success('‚úÖ Affichage de succ√®s', message);
        DOM.setText('authSuccess', message);
        DOM.setDisplay('authSuccess', 'block');
        DOM.setDisplay('authError', 'none');
    }

    hideMessages() {
        DOM.setDisplay('authError', 'none');
        DOM.setDisplay('authSuccess', 'none');
    }
}

// =============================================================================
// INITIALISATION GLOBALE
// =============================================================================

Logger.log('üéÆ D√©marrage d\'Eminium Launcher');

document.addEventListener('DOMContentLoaded', () => {
    Logger.log('‚úÖ DOM pr√™t, initialisation de l\'application');

    // Cr√©er l'instance principale
    const launcher = new EminiumLauncher();

    // Gestionnaire d'erreurs global
    window.addEventListener('error', (e) => {
        Logger.error('üí• Erreur JavaScript globale', {
            message: e.message,
            filename: e.filename,
            line: e.lineno
        });
    });

    window.addEventListener('unhandledrejection', (e) => {
        Logger.error('üí• Promise rejet√©e non g√©r√©e', e.reason);
    });

    Logger.success('üéØ Eminium Launcher charg√© et pr√™t !');
});

// Exposer globalement pour le d√©bogage
window.EminiumLauncher = EminiumLauncher;
